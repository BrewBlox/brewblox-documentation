# USB Proxy Service

Date: 2024/06/28

## TODO

- USB connections only for Spark <4
- USB always optional, even for Spark 2/3
- devcon must be privileged for USB
- devcon must restart to find new USB devices unless /dev mounted
- mounting /dev in a generic service is a security risk
- socat is already used to bridge between a USB serial device (`/dev/ttyACM0`) and a TCP port.
- in Linux, we can detect USB devices by iterating over `/sys/class/tty/ttyACM*`.
- separate service that discovers USB devices, and then start socat for each detected device
- service has REST endpoint to list detected devices and their associated port.
- this is very straightforward behavior, and doesn't need a full python service.
- C++ application in Alpine Docker image -> 15MB image size (300MB for Debian + Python)
- header-only library for REST API, to avoid glibc dependency in dynamic library
- Disabled by default
- Prompt users to enable service in brewblox.yml if desired

```python
from glob import glob
from pathlib import Path

for tty in glob('/sys/class/tty/ttyACM*'):
    tty = Path(tty)

    if (tty / 'device' / 'subsystem').resolve() != Path('/sys/bus/usb'):
        continue

    dev_root = (tty / 'device').resolve() / '..'
    usb_vid = (dev_root / 'idVendor').read_text().strip()
    usb_pid = (dev_root / 'idProduct').read_text().strip()
    usb_device_id = (dev_root / 'serial').read_text().strip()

    if usb_vid != '2b04' or usb_pid not in ['c006', 'c008']:
        continue

    print(tty)
    print('\t', f'{usb_vid}:{usb_pid}')
    print('\t', usb_device_id)
    print('\t', '/dev/' + tty.name)
```

## Context

For basic communication, the Spark 2 and 3 support USB connections.
The Spark 4 has phased out USB in favor of ethernet.
Future Spark models are not expected to re-introduce USB,
as we want to make use of the greater physical flexibility offered by TCP/IP networking.

The Spark [Cbox protocol](../reference/cbox.md) is a message-based protocol.
Message separators are defined to support its use in serial streams.
While the Spark 2 and 3 support USB connections, this should be thought of
as an alternative way to implement a serial stream.
The actual USB communication is an implementation detail.

Because it has to support USB connections, the Spark service faces limitations and vulnerabilities.
For it to communicate with any USB serial device, the Docker container must run
in privileged mode.
For it to detect newly connected devices, it must mount the host `/dev` directory.\
The first restriction is unavoidable, the second is unacceptable,
as it gives the container unrestricted access to all connected hard drives and devices.\
A workaround is to periodically restart the container when it fails to discover the desired Spark controller.

For these reasons, it is desirable to isolate USB connectivity by creating a service
that acts as USB-TCP bridge.
The Spark service is then no longer burdened by the limitations of legacy controller models,
and can leverage TCP/IP networking to enable more flexible container deployment.

## Features

A proxy service must implement three required features:

- It must discover Spark USB devices.
- It must create a bridge between a bound TCP port and the Spark USB serial device.
- It must offer a discoverability mechanism so client Spark devices can find and use the correct TCP port.

### USB Discovery

On Linux hosts, we can perform serial device discovery by iterating over the `/sys/class/tty/` directory.
Spark 2 and 3 controllers present themselves to the host as as USB devices that implement the Abstract Control Model (ACM).
They will be assigned a `ttyACM{0-256}` slot.
There's a [lot of history behind USB and ACM](https://rfc1149.net/blog/2013/03/05/what-is-the-difference-between-devttyusbx-and-devttyacmx/),
but the important part is simple: you can open `/dev/ttyACM{0-256}` as a serial stream.

The directory tree in `/sys/class/tty/` involves a lot of symlinks for connected devices.
By following these symlinks, we can find the relevant metadata for our devices:
USB Vendor ID (vid) and Product ID (pid), and device serial number (used as device ID).

To discover Spark 2 / 3 devices in Python:

```python
from glob import glob
from pathlib import Path

for tty in glob('/sys/class/tty/ttyACM*'):
    tty = Path(tty)

    if (tty / 'device' / 'subsystem').resolve() != Path('/sys/bus/usb'):
        continue

    dev_root = (tty / 'device').resolve() / '..'
    usb_vid = (dev_root / 'idVendor').read_text().strip()
    usb_pid = (dev_root / 'idProduct').read_text().strip()
    usb_device_id = (dev_root / 'serial').read_text().strip()

    # Particle vid = 2b04
    # Photon pid = c006
    # P1 pid = c008
    if usb_vid != '2b04' or usb_pid not in ['c006', 'c008']:
        continue

    print(tty)
    print('\t', f'{usb_vid}:{usb_pid}')
    print('\t', usb_device_id)
    print('\t', '/dev/' + tty.name)
```

### Bridging

The simplest way to implement a USB-TCP bridge is to use [socat](https://linux.die.net/man/1/socat).
It does exactly what we want, and is widely available on Linux.
If we found a Spark device on `/dev/ttyACM0`, and wanted to bind its serial stream to port 9000,
we can do so with the following command:

```sh
socat \
  tcp-listen:9000,reuseaddr,fork \
  file:/dev/ttyACM0,raw,echo=0,b115200
```

Now, connecting to `localhost:9000` will be the equivalent of
opening a serial stream to `/dev/ttyACM0` with 115200 baud rate.

### Proxy Discovery

If we have a service that bridges USB serial devices to TCP ports,
then the natural mechanism for listing these devices and ports is also TCP.
The simplest solution is to have a REST server that can be queried for an index.

## Implementation

TODO
