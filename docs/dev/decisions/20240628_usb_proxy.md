# USB Proxy Service

Date: 2024/06/28

## TODO

- USB connections only for Spark <4
- USB always optional, even for Spark 2/3
- devcon must be privileged for USB
- devcon must restart to find new USB devices unless /dev mounted
- mounting /dev in a generic service is a security risk
- socat is already used to bridge between a USB serial device (`/dev/ttyACM0`) and a TCP port.
- in Linux, we can detect USB devices by iterating over `/sys/class/tty/ttyACM*`.
- separate service that discovers USB devices, and then start socat for each detected device
- service has REST endpoint to list detected devices and their associated port.
- this is very straightforward behavior, and doesn't need a full python service.
- C++ application in Alpine Docker image -> 15MB image size (300MB for Debian + Python)
- header-only library for REST API, to avoid glibc dependency in dynamic library
- Disabled by default
- Prompt users to enable service in brewblox.yml if desired

```python
from glob import glob
from pathlib import Path

for tty in glob('/sys/class/tty/ttyACM*'):
    tty = Path(tty)

    if (tty / 'device' / 'subsystem').resolve() != Path('/sys/bus/usb'):
        continue

    dev_root = (tty / 'device').resolve() / '..'
    usb_vid = (dev_root / 'idVendor').read_text().strip()
    usb_pid = (dev_root / 'idProduct').read_text().strip()
    usb_device_id = (dev_root / 'serial').read_text().strip()

    if usb_vid != '2b04' or usb_pid not in ['c006', 'c008']:
        continue

    print(tty)
    print('\t', f'{usb_vid}:{usb_pid}')
    print('\t', usb_device_id)
    print('\t', '/dev/' + tty.name)
```
